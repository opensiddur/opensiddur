<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:tei="http://www.tei-c.org/ns/1.0"
  xmlns:j="http://jewishliturgy.org/ns/jlptei/1.0"
  xmlns:r="http://jewishliturgy.org/ns/parser-result"  
  xmlns:func="http://jewishliturgy.org/ns/functions/xslt"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:xd="http://www.pnp-software.com/XSLTdoc"
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
  xmlns:cc="http://web.resource.org/cc/"
  xmlns:err="http://jewishliturgy.org/apps/error"
  exclude-result-prefixes="xs r func rdf cc err"
  extension-element-prefixes="func xd"
  >
  <xsl:import href="../../common/cRef.xsl2"/>
  <xsl:import href="../../common/params.xsl2"/>
  <xsl:import href="../../common/common.xsl2"/>
  <xsl:import href="split-word.xsl2"/>
  <xsl:import href="pre-encode.xsl2"/>
  <xsl:include href="../fill-template.xsl2"/>
  <xsl:include href="../../grammar-parser/grammar2.xsl2"/>
  
  <xsl:output indent="yes" encoding="utf-8" method="xml"/>
  <xd:doc type="stylesheet">
	<xd:short>Conversion of raw text XML with the STML grammar.</xd:short>
  	<xd:copyright>Copyright 2010-2011 Efraim Feinstein</xd:copyright>
	<xd:detail>
      <p>This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Lesser General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.</p>

      <p>This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Lesser General Public License for more details.</p>

      <p>You should have received a copy of the GNU Lesser General Public License
      along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
      
      <p>How to add a new element: modes:
      <ul>
        <li>group-segments: group segment-level elements, remove others</li>
        <li>index-selection: set up selection pointers for the index file (only useful for FileCommand)</li>
        <li>l: set up the lines in the lg view</li>
        <li>make-notes: make notes for the notes file, ignore everything else</li>
        <li>make-note-references: make links for the notes file</li>
        <li>make-conditional-references: make links to conditionals in the j:links section</li> 
        <li>p: set up the paragraph view</li>
        <li>remove-footrefs: remove references to footnotes and other elements 
        that are left by mode=repository, but that don't go into the repository.</li>
        <li>repository: include only elements that go into the text j:repository</li>
        <li>selection: sets up pointers in the selection</li>
        <li>verse: set up the chapter-verse view</li>
      </ul>       
      </p>
    </xd:detail>
    <xd:svnId>$Id: rawtext.xsl2 759 2011-04-24 03:29:43Z efraim.feinstein $</xd:svnId>
  </xd:doc>
  <!-- TODO:
    add a poetic mode
    make {include URI} work
    set up {parallel {...}={...}}    
   -->
  <xd:doc>
    Name of input file (include full path!).  Only used if standalone. Otherwise, takes a single /text element.
  </xd:doc>
  <xsl:param name="input-filename" as="xs:string" select="'test.txt'"/>
	
  <xd:doc>
    <xd:short>output directory</xd:short>
  </xd:doc>
  <xsl:param name="output-directory" as="xs:string" select="'.'"/>
  
  <xd:doc>
    Path to the grammar file (usually OK at the default)
  </xd:doc>
  <xsl:param name="grammar-filename" as="xs:string" select="'../../grammar-parser/stml-grammar.xml'"/>
  
  <xd:doc>
    Default language as an ISO-639-* abbreviation
  </xd:doc>
  <xsl:param name="default-language" as="xs:string" select="'en'"/>
  
  <xd:doc>
    Name of the global bibliography entry.  Do not include preceding # sign or filename.
  </xd:doc>
  <xsl:param name="bibl-pointer" as="xs:string" select="'UNDECLARED'"/>
  
  <xd:doc>
    Prefix for conditionals implicitly declared (for notes)
  </xd:doc>
  <xsl:param name="conditional-name" as="xs:string" select="'UNDECLARED'"/>
  
  <xd:doc>
    Filename of generated index.
  </xd:doc>
  <xsl:param name="index-name" as="xs:string" select="'index.xml'"/>
  
  <xd:doc>
    Title of generated index.
  </xd:doc>
  <xsl:param name="index-title" as="xs:string" select="'INDEX'"/>
  
  <xd:doc>
    Prefix for facsimile graphics URI.  Empty string for born digital documents.
  </xd:doc>
  <xsl:param name="facsimile-prefix" as="xs:string?" select="'/scans/SOURCE-NAME'"/>
    
  <xd:doc>
    Extension (or suffix) for facsimile graphics URIs
  </xd:doc>
  <xsl:param name="facsimile-extension" as="xs:string" select="'.jpg'"/>

  <xd:doc>
    License type, which may be cc0, cc-by, or cc-by-sa. 
  </xd:doc>
  <xsl:param name="license-type" as="xs:string" select="'cc0'"/> 

  <xd:doc>
    Index of sections by generated idref
  </xd:doc>
  <xsl:key name="sections" match="r:SectionCommand" use="generate-id(.)"/>
  
  <xd:doc>
    Index all of the segments that have added continue commands by
    the true false value
  </xd:doc>
  <xsl:key name="added-cont-commands" 
    match="r:SegmentedText[not(descendant::r:ContCommand)
        and not(preceding-sibling::*[
          self::r:VerseDivision or 
          self::r:SegmentedText or 
          self::r:IncludeCommand or 
          self::r:BibleCommand])
        and parent::r:ParagraphText/preceding::r:ParagraphText[1]
          [not(descendant::r:SegmentedText[last()]/r:Pausal = ('.','?','×ƒ'))]
        and matches(.,'^\s*\p{Ll}')]" 
    use="."/>

  <xd:doc>
    Index of broken segments
  </xd:doc>
  <xsl:key name="broken-segments" 
    match="r:SegmentedText[
      normalize-space(.) 
        and 
        (following::r:SegmentedText[1]/(descendant::r:ContCommand or 
          key('added-cont-commands', .)) 
        and not(descendant::r:Pausal)
        and not((preceding::r:PoetryMode|preceding::r:ProseMode)[1]/self::r:PoetryMode)
        )]"
    use="."/>

  <xsl:key name="count-of-preceding-blocks" 
    match="preceding-blocks/@n" use="../@segment"/>
    
  <xsl:key name="count-of-preceding-segments" 
    match="preceding-segments/@n" use="../@segment"/>
  
  <xd:doc>
    Index of count of preceding notes by generated id
  </xd:doc>
  <xsl:key name="count-of-preceding-notes" 
    match="preceding-notes/@n" use="../@note"/>
 
  <xd:doc>
    Hold the parsed grammar
  </xd:doc>
  <xsl:variable name="grammar-parsed" as="document-node()">
    <xsl:variable name="text" as="xs:string" 
      select="unparsed-text($input-filename)"/>
    <xsl:document>
      <xsl:variable name="g-p" as="element()+"
        select="func:grammar-clean(
        func:grammar-parse($text, 'AllContent', doc($grammar-filename)))"/>
      <xsl:choose>
        <xsl:when test="$g-p/self::r:remainder">
          <xsl:message terminate="yes">
Cannot parse the given file. Terminated with a remainder. The first 100 characters of the remainder are displayed below:
<xsl:sequence select="substring($g-p/self::r:remainder, 1, 100)"/>

The previous match was:
<xsl:sequence select="$g-p/self::r:AllContent/(if (string(.)) then (.//*)[last()] else 'empty')"/>
          </xsl:message>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$g-p"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:document>
  </xsl:variable>
 
  <xd:doc>
    Speed optimization to count the number of preceding blocks of each segment 
    and index it by the segment's generated id
  </xd:doc>
  <xsl:variable name="preceding-block-count" as="document-node()">
    <xsl:document>
      <xsl:message>Building block count index...</xsl:message>
      <p-b>
        <xsl:apply-templates select="$grammar-parsed//r:SegmentedText" mode="preceding-blocks"/>
      </p-b>
    </xsl:document>
  </xsl:variable>
  
  <xd:doc>
    Speed optimization to count the number of preceding segments of each segment 
    and index it by the segment's generated id
  </xd:doc>
  <xsl:variable name="preceding-segment-count" as="document-node()">
    <xsl:document>
      <xsl:message>Building segment count index...</xsl:message>
      <p-s>
        
        <xsl:apply-templates select="$grammar-parsed//r:SegmentedText" mode="preceding-segments"/>
      </p-s>
    </xsl:document>
  </xsl:variable>
  
  <xd:doc>
    Speed optimization to count the number of preceding notes in a given file
    and index it by the note's generated id
  </xd:doc>
  <xsl:variable name="preceding-note-count" as="document-node()">
    <xsl:document>
      <xsl:message>Building note count index...</xsl:message>
      <p-n>
        <xsl:apply-templates select="$grammar-parsed//r:NoteCommand" mode="preceding-notes"/>
      </p-n>
    </xsl:document>
  </xsl:variable>
  
  <xsl:template match="r:SegmentedText" mode="preceding-blocks">
    <preceding-blocks segment="{generate-id(.)}">
      <xsl:attribute name="n">
        <xsl:variable name="origin-element" as="element()"
          select="(ancestor::r:ParagraphText[1], .)[1]"/>
        
        <xsl:variable name="start-point" as="element()" 
          select="(preceding::r:FileCommand[1], root(.)//*[1], .)[1]"/>
        
        <xsl:sequence select="
          count($origin-element/preceding::*
            [. >> $start-point][
            self::r:ParagraphText[normalize-space(.)] or
            self::r:BibleBlockCommand or 
            self::r:IncludeBlockCommand]
            ) 
          (: actual continue commands :)
           - count($origin-element/descendant::r:ContCommand)
          - count($origin-element/preceding::r:ContCommand[. >> $start-point])  
          (: added continue commands :)
          - count(key('added-cont-commands', $origin-element/descendant::r:SegmentedText[1], $origin-element)) 
          - count($origin-element/preceding::*[. >> $start-point]
              [self::r:SegmentedText or self::r:IncludeCommand]
              [key('added-cont-commands', ., $origin-element)])"/>
      </xsl:attribute>
    </preceding-blocks>
  </xsl:template>

  <xsl:template match="r:SegmentedText" mode="preceding-segments">
    <preceding-segments segment="{generate-id(.)}">
      <xsl:attribute name="n">
        <xsl:variable name="verse-div" as="element(r:VerseDivision)?"
          select="preceding::r:VerseDivision[1][. >> ancestor::r:ParagraphText[1]]"/>
        <xsl:variable name="context-block" as="xs:integer" select="
          if ($verse-div) then 0 
          else func:count-preceding-blocks(.)"/>
        <xsl:variable name="count-start" as="element()"
          select="(preceding::r:FileCommand[1], root(.)//*[1], .)[1]"/>     
        <xsl:sequence select="(if ($verse-div) 
          then count(preceding::*
            [(self::r:SegmentedText|self::r:IncludeCommand|self::r:BibleCommand)
            [. >> $verse-div]
            [not(key('broken-segments', .))]])
          else count(preceding::*
            [self::r:SegmentedText or self::r:IncludeCommand or self::r:BibleCommand]
            [. >> $count-start]
            [not(key('broken-segments', .))]
            [func:count-preceding-blocks(.)=$context-block]
            ))"/>
      </xsl:attribute> 
    </preceding-segments>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Count preceding notes</xd:short>
  </xd:doc>
  <xsl:template match="r:NoteCommand" mode="preceding-notes">
    <preceding-notes note="{generate-id(.)}">
      <xsl:variable name="count-start" as="element()"
        select="(preceding::r:FileCommand[1], root(.)//*[1], .)[1]"/>
      <xsl:attribute name="n" 
        select="count(preceding::r:NoteCommand[. >> $count-start])"/>
    </preceding-notes> 
  </xsl:template>
  
  <xd:doc>
    <xd:short>Assemble the URI of a facsimile.  Assume that it is stored with the
    page number.</xd:short>
    <xd:param name="page">Page number of the text</xd:param>
  </xd:doc>
  <xsl:function name="func:facsimile-url" as="xs:string">
    <xsl:param name="page" as="xs:string"/>
    <xsl:sequence select="string-join((
      $facsimile-prefix,
      if (ends-with($facsimile-prefix, '/')) then '' else '/', 
      $page,
      $facsimile-extension),'')"/>
  </xsl:function>
  
  <xd:doc>
    License boilerplate for CC0
  </xd:doc>
  <xsl:variable name="cc0-license" as="element()+">
    <tei:p xml:lang="en">
      To the extent possible under law, the contributors who associated
      <tei:ref type="license" target="http://www.creativecommons.org/publicdomain/zero/1.0">Creative Commons Zero
      </tei:ref>
      with this work have waived all copyright and related or neighboring rights to this work.
    </tei:p>
    <rdf:RDF>
      <cc:License rdf:about="http://creativecommons.org/publicdomain/zero/1.0/">
        <cc:legalcode
          rdf:resource="http://creativecommons.org/publicdomain/zero/1.0/legalcode" />
        <cc:permits rdf:resource="http://creativecommons.org/ns#Reproduction" />
        <cc:permits rdf:resource="http://creativecommons.org/ns#Distribution" />
      </cc:License>
    </rdf:RDF>
  </xsl:variable>

  <xd:doc>
    License boilerplate for CC-BY
  </xd:doc>
  <xsl:variable name="cc-by-license" as="element()+">
    <tei:p xml:lang="en">Copyright <tei:date><xsl:value-of select="year-from-date(current-date())"/></tei:date> by the Contributors to the Open Siddur Project. 
    This file is available under the 
    <tei:ref type="license" target="http://www.creativecommons.org/licenses/by/3.0">Creative Commons Attribution 3.0 Unported</tei:ref> license.  
    </tei:p>
    <rdf:RDF>
      <cc:License rdf:about="http://creativecommons.org/licenses/by/3.0/">
        <cc:legalcode rdf:resource="http://creativecommons.org/licenses/by/3.0/legalcode"/>
        <cc:permits rdf:resource="http://creativecommons.org/ns#DerivativeWorks"/>
        <cc:permits rdf:resource="http://creativecommons.org/ns#Distribution"/>
        <cc:permits rdf:resource="http://creativecommons.org/ns#Reproduction"/>
        <cc:requires rdf:resource="http://creativecommons.org/ns#Notice"/>
        <cc:requires rdf:resource="http://creativecommons.org/ns#Attribution"/>
      </cc:License>
    </rdf:RDF>
  </xsl:variable>

  <xd:doc>
    License boilerplate for CC-BY-SA
  </xd:doc>
  <xsl:variable name="cc-by-sa-license" as="element()+">
    <tei:p xml:lang="en">Copyright <tei:date><xsl:value-of select="year-from-date(current-date())"/></tei:date> by the Contributors to the Open Siddur Project. 
    This file is available under the 
    <tei:ref type="license" target="http://www.creativecommons.org/licenses/by-sa/3.0">Creative Commons Attribution 3.0 Unported</tei:ref> 
    license.
    </tei:p>
    <rdf:RDF>
      <cc:License rdf:about="http://creativecommons.org/licenses/by-sa/3.0/">
        <cc:legalcode rdf:resource="http://creativecommons.org/licenses/by-sa/3.0/legalcode"/>
        <cc:permits rdf:resource="http://creativecommons.org/ns#DerivativeWorks"/>
        <cc:permits rdf:resource="http://creativecommons.org/ns#Reproduction"/>
        <cc:permits rdf:resource="http://creativecommons.org/ns#Distribution"/>
        <cc:requires rdf:resource="http://creativecommons.org/ns#Attribution"/>
        <cc:requires rdf:resource="http://creativecommons.org/ns#ShareAlike"/>
        <cc:requires rdf:resource="http://creativecommons.org/ns#Notice"/>
      </cc:License>
    </rdf:RDF>
  </xsl:variable>
  
  <xd:doc>
    <xd:short>This is the starting point.</xd:short>
  </xd:doc>
  <xsl:template match="r:AllContent">
    <xsl:message>License type: <xsl:value-of select="$license-type"/></xsl:message>
    <xsl:variable name="all-content" as="element(r:AllContent)" select="."/>
    <xsl:variable name="selected-license" as="element()+" 
      select="if ($license-type eq 'cc0') 
            then $cc0-license
            else if ($license-type eq 'cc-by')
            then $cc-by-license
            else if ($license-type eq 'cc-by-sa')
            then $cc-by-sa-license
            else
              (func:debug(
              concat('Unknown or unsupported license type: ', $license-type),
              'Raw text converter', 
              $debug-error), $cc0-license) "/> 
    <result-document href="{$output-directory}/contributors.xml">
      <tei:list type="contributors">
        <xsl:for-each select="distinct-values(r:ContribCommand/r:Name)">
          <tei:item>
            <xsl:attribute name="xml:id" select="replace(normalize-space(.),'\s+','.')"/>
            <tei:forename>???</tei:forename>
            <tei:surname>???</tei:surname>
            <tei:email>???</tei:email>
          </tei:item>
        </xsl:for-each>
      </tei:list>
    </result-document> 
    
    <xsl:if test="descendant::r:FileCommand">
      <!-- make the index file -->
      <result-document href="{$output-directory}/{$index-name}">
        <xsl:apply-templates select="$template" mode="fill-template">
          <xsl:with-param name="title" as="element(tei:title)" tunnel="yes">
            <tei:title><xsl:sequence select="$index-title"/></tei:title>
          </xsl:with-param>
          <xsl:with-param name="license" as="element()+" tunnel="yes" 
            select="$selected-license"/>
          <xsl:with-param name="bibl" tunnel="yes" as="element(tei:bibl)">
            <tei:bibl>
              <xsl:attribute name="xml:id" select="'bibl-local'"/>
              <tei:ptr target="../bibliography/{$bibl-pointer}.xml"/>
              <xsl:variable name="pages" as="xs:string*" 
                select="(descendant::r:PageBreakCommand|descendant::r:FootnotePageBreakCommand)/r:PageNumber"/>
              <xsl:if test="exists($pages)">
                <tei:biblScope type="pp" from="{$pages[1]}" to="{$pages[last()]}"/>
              </xsl:if>
            </tei:bibl>
          </xsl:with-param>
          <xsl:with-param name="links" as="element(j:links)?" tunnel="yes">
            <j:links>
              <tei:link type="source" targets="#repository #bibl-local"/>
            </j:links>
          </xsl:with-param>
          <xsl:with-param name="body" as="element(tei:body)" tunnel="yes">
            <tei:body>
              <j:concurrent>
              	<xsl:attribute name="xml:id" select="'concurrent'"/>
                <xsl:variable name="selection-index" as="element(tei:ptr)+">
                  <xsl:apply-templates select="descendant::r:FileCommand" mode="index-selection"/>
                </xsl:variable>
                <j:selection>
               	  <xsl:attribute name="xml:id" select="'selection'"/>
                  <xsl:sequence select="$selection-index"/>
                </j:selection>
                <j:view type="div">
                  <xsl:attribute name="xml:id" select="'view_div'"/>
                  <tei:div>
                    <xsl:attribute name="xml:id" select="'main'"/>
                    <tei:ab>
                      <tei:ptr target="#range({$selection-index[1]/@xml:id},{$selection-index[last()]/@xml:id})">
                        <xsl:attribute name="xml:id" select="'div_1'"/>
                      </tei:ptr>
                    </tei:ab>
                  </tei:div>
                </j:view>
              </j:concurrent>
            </tei:body>
          </xsl:with-param>
        </xsl:apply-templates>
      </result-document>
    </xsl:if>
    
    <xsl:for-each-group select="element()" group-starting-with="r:FileCommand">
      <xsl:variable name="file-element" as="element(r:FileCommand)?"
        select="current-group()[1]/self::r:FileCommand"/>
      <xsl:variable name="title" as="xs:string" 
        select="($file-element/r:Title, 'UNTITLED')[1]"/>
      
      <!-- grouped segments includes: 
        SegmentedText, 
        IncludeCommand,
        IncludeBlockCommand,
        BibleCommand,
        BibleBlockCommand -->
      <!-- xsl:message>current-group() = <xsl:sequence select="current-group()"/></xsl:message-->
      <xsl:variable name="grouped-segments" as="element()*">
        <xsl:apply-templates select="current-group()" mode="group-segments"/>
      </xsl:variable>
      <xsl:if test="$grouped-segments"><!-- empty files usually mean commands before filename -->
        <xsl:variable name="pages" as="xs:string*"
          select="distinct-values($grouped-segments/@page)"/>
        
        <xsl:variable name="notes" as="element()*"
          select="current-group()/self::r:FootNoteCommand|
            current-group()/descendant-or-self::r:NoteCommand"/>
        
        <xsl:variable name="base-file-name" as="xs:string"
          select="func:name-file($file-element)"/>
        <xsl:message>Base file name=<xsl:value-of select="$base-file-name"/></xsl:message>
        
        <xsl:variable name="bibl-content" as="element(tei:bibl)">
          <tei:bibl>
            <xsl:attribute name="xml:id" select="'bibl-local'"/>
            <tei:ptr target="../bibliography/{$bibl-pointer}.xml"/>
            <xsl:if test="not(empty($pages))">
              <tei:biblScope type="pp" from="{$pages[1]}" to="{$pages[last()]}"/>
            </xsl:if>
          </tei:bibl>
        </xsl:variable>
        
        <!-- xsl:message>grouped-segments = <xsl:sequence select="$grouped-segments"/></xsl:message-->
  
        <xsl:variable name="repository-content" as="element()+">
          <xsl:apply-templates select="$grouped-segments" mode="repository">
            <xsl:with-param name="current-grouping" as="element()*" tunnel="yes"
              select="current-group()"/>
          </xsl:apply-templates>
        </xsl:variable>
        
        <xsl:if test="$notes">
          <xsl:variable name="notes-pages" as="xs:string*" 
            select="for $note in $notes return ($note/preceding::r:PageBreakCommand[1]/r:PageNumber|$note/descendant::r:FootnotePageBreakCommand/r:PageNumber)"/>
        
          <result-document href="{string-join(($output-directory, '/', $base-file-name, '-notes.xml'),'')}">
            <xsl:apply-templates select="$template" mode="fill-template">
              <xsl:with-param name="xmllang" as="xs:string" tunnel="yes"
                select="$default-language"/>
              <xsl:with-param name="title" as="element(tei:title)" tunnel="yes">
                <tei:title><xsl:sequence select="$title"/> (notes)</tei:title>
              </xsl:with-param>
              <xsl:with-param name="license" as="element()+" tunnel="yes" select="$selected-license"/>
              <xsl:with-param name="bibl" as="element(tei:bibl)"  tunnel="yes">
                <tei:bibl>
                  <xsl:attribute name="xml:id">bibl-local</xsl:attribute>
                  <tei:ptr target="../bibliography/{$bibl-pointer}.xml"/>
                  <xsl:for-each select="distinct-values($notes-pages)">
                    <tei:biblScope type="pp" from="{.}" to="{.}">
                      <xsl:attribute name="xml:id" select="concat('bibl_page_',.)"/>
                    </tei:biblScope>
                  </xsl:for-each>
                </tei:bibl>
              </xsl:with-param>
              <xsl:with-param name="respList" as="element(j:respList)" tunnel="yes">
                <j:respList>
                  <xsl:for-each select="$notes">
                    <xsl:call-template name="add-respons">
                      <xsl:with-param name="target" as="xs:anyURI"
                        select="xs:anyURI(concat('#',func:make-note-id(.)))"/>
                      <xsl:with-param name="contrib-list" as="element(r:ContribCommand)*" 
                        select="
                        if (preceding::r:PageNumber)
                        then
                          func:get-contrib-commands-by-page((
                            string(preceding::r:PageNumber[1]),
                            for $fp in descendant::r:FootnotePageBreakCommand
                            return string($fp/r:PageNumber)
                          ), $all-content)
                        else
                          func:get-contrib-commands-by-file(preceding::r:FileCommand[1], $all-content)"/>
                    </xsl:call-template>
                  </xsl:for-each>
                </j:respList>
              </xsl:with-param>
              <xsl:with-param name="body" as="element(tei:body)" tunnel="yes">
                <tei:body>
                  <tei:div type="notes">
                    <xsl:attribute name="xml:id" select="'notes'"/>
                    <xsl:apply-templates select="$notes" mode="make-notes">
                      <!-- current-grouping parameter tunnels to repository mode -->
                      <xsl:with-param name="current-grouping" as="element()+" tunnel="yes" select="current-group()"/>
                    </xsl:apply-templates>
                  </tei:div>
                </tei:body>
              </xsl:with-param>
              <xsl:with-param name="links" as="element(j:links)?" tunnel="yes">
                <j:links>
                  <tei:link type="source" targets="#repository #bibl-local"/>
                  <xsl:apply-templates select="$notes" mode="make-note-references">
                    <xsl:with-param name="base-file-name" as="xs:string"
                      select="$base-file-name"/>
                    <xsl:with-param name="repository" as="element()+"
                      select="$repository-content"/>
                  </xsl:apply-templates>
                </j:links>
              </xsl:with-param>
              <xsl:with-param name="conditionGrp" tunnel="yes" as="element(j:conditionGrp)">
                <j:conditionGrp>
                  <tei:fvLib>
                    <tei:symbol xml:id="NO" value="NO"/>
                    <tei:symbol xml:id="YES" value="YES"/>
                  </tei:fvLib>
                  <tei:fLib>
                    <tei:fs type="{$conditional-name}">
                      <xsl:attribute name="xml:id" select="concat($conditional-name,'-all-notes_Y')"/>
                      <tei:f name="{$conditional-name}-all-notes" fVal="#YES"/>
                    </tei:fs>
                    <tei:fs type="{$conditional-name}">
                      <xsl:attribute name="xml:id" select="concat($conditional-name,'-all-notes_N')"/>
                      <tei:f name="{$conditional-name}-all-notes" fVal="#NO"/>
                    </tei:fs>                  
                    <xsl:for-each select="$notes">
                      <xsl:variable name="note-id" as="xs:string" select="func:make-note-id(.)"/>
                      <tei:fs type="{$conditional-name}">
                        <xsl:attribute name="xml:id" select="concat($conditional-name,'-',$note-id,'_Y')"/>
                        <tei:f name="{$conditional-name}-{$note-id}" fVal="#YES"/>
                      </tei:fs>
                      <tei:fs type="{$conditional-name}">
                        <xsl:attribute name="xml:id" select="concat($conditional-name,'-',$note-id,'_N')"/>
                        <tei:f name="{$conditional-name}-{$note-id}" fVal="#NO"/>
                      </tei:fs>
                    </xsl:for-each>
                  </tei:fLib>
                  <xsl:for-each select="$notes">
                    <xsl:variable name="note-id" as="xs:string" select="func:make-note-id(.)"/>
                    <!-- associate the note to both the conditional controlling all and its specific conditional
                    but only use the all conditional if the specific is YES -->
                    <tei:link type="conditional" targets="#assoc-{$note-id}-all #{$conditional-name}-{$note-id}_Y">
                      <xsl:attribute name="xml:id" select="concat('cond-',$note-id)"/>
                    </tei:link>
                    <tei:link type="association" targets="#{$note-id} #{$conditional-name}-{$note-id}_Y">
                      <xsl:attribute name="xml:id" select="concat('assoc-',$note-id)"/>
                    </tei:link>
                    <tei:link type="association" targets="#{$note-id} #{$conditional-name}-all-notes_Y">
                      <xsl:attribute name="xml:id" select="concat('assoc-',$note-id,'-all')"/>
                    </tei:link>
                  </xsl:for-each>
                </j:conditionGrp>
              </xsl:with-param>
              <xsl:with-param name="fsdDecl" as="element(tei:fsdDecl)?" tunnel="yes">
                <tei:fsdDecl>
                  <tei:fsDecl type="{$conditional-name}">
                    <tei:fDecl name="{$conditional-name}-all-notes">
                      <tei:fDescr xml:lang="en">Include notes from <xsl:value-of select="$conditional-name"/></tei:fDescr>
                      <xsl:call-template name="two-way-condition-no"/>
                    </tei:fDecl>
                    <xsl:for-each select="$notes">
                      <xsl:variable name="note-id" as="xs:string" 
                        select="func:make-note-id(.)"/>
                      <tei:fDecl name="{$conditional-name}-{$note-id}">
                        <tei:fDescr>Include note #<tei:ref target="#{$note-id}"><xsl:value-of select="$note-id"/></tei:ref></tei:fDescr>
                        <xsl:call-template name="two-way-condition-yes"/>
                      </tei:fDecl>
                    </xsl:for-each>
                  </tei:fsDecl>
                </tei:fsdDecl>
              </xsl:with-param>
              <xsl:with-param name="facsimile" as="element(tei:facsimile)?" tunnel="yes">
                <xsl:if test="$facsimile-prefix">
                  <xsl:variable name="facsimile-urls" as="xs:string*"
                    select="for $page in $notes-pages return func:facsimile-url($page)"/>
                  <xsl:if test="exists($facsimile-urls)">
                    <tei:facsimile>
                      <xsl:for-each select="distinct-values($facsimile-urls)">
                        <tei:graphic url="{.}"/>
                      </xsl:for-each>
                    </tei:facsimile>
                  </xsl:if>
                </xsl:if>
              </xsl:with-param>
            </xsl:apply-templates>
          </result-document>
        </xsl:if>
        
        <result-document href="{string-join(($output-directory, '/', $base-file-name, '.xml'),'')}">              
          <xsl:apply-templates select="$template" mode="fill-template">
            <xsl:with-param name="xmllang" as="xs:string" tunnel="yes"
              select="$default-language"/>
            <xsl:with-param name="title" as="element(tei:title)" tunnel="yes">
              <tei:title><xsl:sequence select="$title"/></tei:title>
            </xsl:with-param>
            <xsl:with-param name="license" as="element()+" tunnel="yes" 
              select="$selected-license"/>
            <xsl:with-param name="bibl" as="element(tei:bibl)"  tunnel="yes" 
              select="$bibl-content"/>
            <xsl:with-param name="respList" as="element(j:respList)" tunnel="yes">
              <j:respList>
                <xsl:call-template name="add-respons">
                  <xsl:with-param name="target" as="xs:anyURI"
                    select="xs:anyURI('#repository')"/>
                  <!--  contrib commands come before PageBreakCommand.  This captures 
                  both the contrib commands in the current group and the ones listed preceding 
                  the last page break. -->
                  <xsl:with-param name="contrib-list" as="element(r:ContribCommand)*" 
                    select="
                      if (exists(current-group()/self::r:PageBreakCommand))
                      then
                        func:get-contrib-commands-by-page((
                          for $page in current-group()/self::r:PageBreakCommand/r:PageNumber return string($page),
                          (: check for substantive content from the previous page at the beginning of the file :)
                          if ($file-element/following::*[
                            self::r:SegmentedText or self::r:IncludeCommand or self::r:IncludeBlockCommand]
                            [. &lt;&lt; $file-element/following::r:PageBreakCommand[1] ])
                          then string((current-group()/self::r:PageBreakCommand)[1]/preceding::r:PageBreakCommand[1]/r:PageNumber)
                          else ()
                        ), $all-content)
                      else
                        func:get-contrib-commands-by-file($file-element, $all-content)"/>
                </xsl:call-template>
              </j:respList>
            </xsl:with-param>
            <xsl:with-param name="body" as="element(tei:body)" tunnel="yes">
              <tei:body>
                <xsl:variable name="whole-group" as="element()+" select="current-group()"/>
                
                <j:concurrent>
                  <xsl:attribute name="xml:id" select="'concurrent'"/>
                  <!-- xsl:message>repository-content = <xsl:sequence select="$repository-content"/></xsl:message-->
                  <xsl:variable name="selection-content" as="element(tei:ptr)+">
                    <xsl:apply-templates select="$repository-content" mode="selection"/>
                  </xsl:variable>
                  <j:selection>
                  	<xsl:attribute name="xml:id" select="'selection'"/>
                    <xsl:sequence select="$selection-content"/>
                  </j:selection>
                  <j:view type="div">
                  	<xsl:attribute name="xml:id" select="'view_div'"/>
                    <tei:div>
                      <xsl:attribute name="xml:id" select="'main'"/>
                      <xsl:for-each-group select="$grouped-segments" group-by="@section">
                        <xsl:variable name="section-command" as="element(r:SectionCommand)?"
                          select="key('sections', current-grouping-key(), $all-content)"/>
                        <xsl:element name="{if ($section-command) then 'tei:div' else 'tei:ab'}">
                          <xsl:if test="$section-command">
                            <xsl:attribute name="type" select="'section'"/>
                            <xsl:attribute name="xml:id" select="concat('section', string(position()))"/>
                            <tei:head>
                              <!-- ignores commands inside section headings -->
                              <xsl:value-of select="normalize-space(string-join($section-command/element(), ' '))"/>
                            </tei:head>
                          </xsl:if>
                          <tei:ptr>
                            <xsl:attribute name="xml:id" select="concat('section', string(position()), '_ptr1')"/>
                            <xsl:attribute name="target" select="
                              string-join(
                                if (count(current-group()) &gt; 1)
                                then
                                  ('#range(',
                                  func:segment-id(current-group()[1], 'se', $whole-group),
                                  ',',
                                  func:segment-id(current-group()[last()], 'se', $whole-group),
                                  ')')
                                else
                                  ('#',func:segment-id(current-group(), 'se', $whole-group)), 
                                '')
                            "/>
                          </tei:ptr>
                      	</xsl:element>
                      </xsl:for-each-group>
                    </tei:div>
                  </j:view>
                  <j:view type="p">
                  	<xsl:attribute name="xml:id" select="'view_p'"/>
                    <xsl:for-each-group select="$grouped-segments[@p]" 
                      group-by="xs:integer(@p)">
                      <xsl:sort select="xs:integer(current-grouping-key())" data-type="number" />
                      <!-- xsl:message>group: = <xsl:value-of select="current-grouping-key()"/></xsl:message-->
                      <tei:p>
                        <xsl:attribute name="xml:id" select="concat('p',current-grouping-key())"/>
                        <xsl:apply-templates select="current-group()" mode="p">
                          <xsl:with-param name="current-grouping" as="element()+" 
                            select="$whole-group"/>
                        </xsl:apply-templates>
                      </tei:p>
                    </xsl:for-each-group>
                  </j:view>
                  <xsl:if test="$grouped-segments/@lg">
                    <j:view type="lg">
                      <xsl:attribute name="xml:id" select="'view_lg'"/>
                      <xsl:for-each-group select="$grouped-segments[@lg]" group-by="@lg">
                        <tei:lg>
                          <xsl:attribute name="xml:id" select="concat('lg', current-grouping-key())"/>
                          <xsl:for-each-group select="current-group()" group-by="@l">
                            <xsl:sort select="xs:integer(current-grouping-key())" data-type="number" />
                            <tei:l>
                              <xsl:attribute name="xml:id" select="concat('lg',current-group()[1]/@lg,'_l',current-grouping-key())"/>
                              <xsl:apply-templates select="current-group()" mode="l">
                                <xsl:with-param name="current-grouping" as="element()+" 
                                  select="$whole-group"/>
                              </xsl:apply-templates>
                            </tei:l>
                          </xsl:for-each-group>
                        </tei:lg>
                      </xsl:for-each-group>
                    </j:view>
                  </xsl:if>
                  <xsl:if test="$grouped-segments/@verse">
                    <j:view type="verse">
                      <xsl:attribute name="xml:id" select="'view_verse'"/>
                      <xsl:for-each-group select="$grouped-segments[@verse]" group-by="xs:integer(@chapter)">
                        <xsl:sort select="xs:integer(@chapter)" data-type="number" />
                        <xsl:for-each-group select="current-group()" group-by="xs:integer(@verse)">
                          <xsl:sort select="xs:integer(@verse)" data-type="number" />
                          <xsl:if test="current-group()/@verse">
                            <xsl:variable name="chapter" as="xs:string" 
                              select="(current-group()/@chapter)[1]"/>
                            <xsl:variable name="verse" as="xs:string" 
                              select="(current-group()/@verse)[1]"/>
                            <tei:ab>
                              <xsl:attribute name="xml:id" select="concat('c',$chapter,'_v',$verse)"/>
                              <tei:label n="chapter"><xsl:value-of select="$chapter"/></tei:label>
                              <tei:label n="verse"><xsl:value-of select="$verse"/></tei:label>
                              <xsl:apply-templates select="current-group()" mode="verse">
                                <xsl:with-param name="current-grouping" as="element()+" 
                                  select="$whole-group"/>
                              </xsl:apply-templates>
                            </tei:ab>
                          </xsl:if>
                        </xsl:for-each-group>
                      </xsl:for-each-group>
                    </j:view>
                  </xsl:if>
                  <!-- segments inside named content -->
                  <xsl:if test="$grouped-segments/@name">
                    <j:view type="ab">
                      <xsl:attribute name="xml:id" select="'view_ab_named'"/>
                      <xsl:for-each-group select="$grouped-segments[@name]" group-by="@name">
                        <tei:ab>
                          <xsl:attribute name="xml:id" select="current-grouping-key()"/>
                          <xsl:apply-templates select="current-group()" mode="name">
                            <xsl:with-param name="current-grouping" as="element()+"
                              select="current-group()"/>
                          </xsl:apply-templates>
                        </tei:ab>
                      </xsl:for-each-group>
                    </j:view>
                  </xsl:if>
                </j:concurrent>
                <j:repository>
                  <xsl:attribute name="xml:id">repository</xsl:attribute>
                  <xsl:apply-templates select="$repository-content" mode="remove-footrefs"/>
                </j:repository>
              </tei:body>
            </xsl:with-param>
            <xsl:with-param name="links" as="element(j:links)?" tunnel="yes">
              <j:links>
                <tei:link type="source" targets="#repository #bibl-local"/>
                <xsl:apply-templates select="current-group()" mode="make-conditional-references"/>
              </j:links>
            </xsl:with-param>
            <xsl:with-param name="fsdDecl" as="element(tei:fsdDecl)?" tunnel="yes">
            </xsl:with-param>
            <xsl:with-param name="facsimile" as="element(tei:facsimile)?" tunnel="yes">
              <xsl:if test="$facsimile-prefix">
                <xsl:variable name="facsimile-urls" as="xs:string*" 
                  select="distinct-values(for $page in $pages 
                    return func:facsimile-url($page))"/>
                <xsl:if test="exists($facsimile-urls)">
                  <tei:facsimile>
                    <xsl:for-each select="$facsimile-urls">
                      <tei:graphic url="{.}"/>
                    </xsl:for-each>
                  </tei:facsimile>
                </xsl:if>
              </xsl:if>
            </xsl:with-param>
          </xsl:apply-templates>
        </result-document>
      </xsl:if>
    </xsl:for-each-group>
  </xsl:template>

  <xd:doc>
    <xd:short>Name a file given its file element (does not include the extension).
    If no element exists, use 'untitled-number'</xd:short>
    <xd:param name="file-element">The element that defines a new file, in its original context.</xd:param>
  </xd:doc>
  <xsl:function name="func:name-file" as="xs:string">
    <xsl:param name="file-element" as="element(r:FileCommand)?"/>
    
    <xsl:sequence select="replace((
          if ($file-element/r:Filename) 
          then replace($file-element/r:Filename, '\.xml', '') 
          else (), 
          if ($file-element/r:Title) 
          then $file-element/r:Title 
          else (), 
          string-join(('untitled-',
            string(count($file-element/preceding::r:FileCommand) + 1)),'')
          )[1], '[\s'']', '_')"/>
  </xsl:function>

  <xd:doc>
    <xd:short>Add a respons element that applies to the URI $target
    and contains the information from $contrib-list
    </xd:short>
    <xd:param name="target">The target of the respons element</xd:param>
    <xd:param name="contrib-list">Contributor elements</xd:param>
  </xd:doc>
  <xsl:template name="add-respons">
    <xsl:param name="target" as="xs:anyURI"/>
    <xsl:param name="contrib-list" as="element(r:ContribCommand)*"/>
    <!-- The group-by construct here is trying to make a different group
    for each name which has a different role.  There's probably a better
    way to do it. -->
    <xsl:for-each-group select="$contrib-list/r:Name" 
      group-by="concat(string(.), (string(../r:Role),'transcriber')[1])">
      <xsl:variable name="name" as="xs:string" select="current-group()[1]"/>
      <xsl:variable name="role" as="xs:string" select="(current-group()[1]/../r:Role,'transcriber')[1]"/>
      <!-- xsl:message>name group: <xsl:sequence select="current-group()"/></xsl:message-->
      <!-- xsl:for-each select="(../r:Role,'transcriber')[1]"-->
        <!-- xsl:variable name="role" as="xs:string" 
          select="current-grouping-key()"/-->
        <tei:respons 
          j:role="{$role}" 
          locus="value" 
          target="{string($target)}" 
          resp="../contributors/{replace(normalize-space($name),'\s+','.')}.xml"/>
      <!-- /xsl:for-each-->
    </xsl:for-each-group>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Return consecutive contrib commands.</xd:short>
  </xd:doc>
  <xsl:function name="func:consecutive-contrib-commands" as="element(r:ContribCommand)*">
    <xsl:param name="context" as="element()?"/>
    <xsl:for-each select="$context">
      <xsl:sequence select="
        if (self::r:ContribCommand)
        then (., 
          func:consecutive-contrib-commands(
            preceding-sibling::*[1]/self::r:ContribCommand)
        )
        else ()"/>
    </xsl:for-each>
  </xsl:function>
  
  <xd:doc>
    <xd:short>Find the r:ContribCommand elements that apply to a
    given page.</xd:short>
  </xd:doc>
  <xsl:function name="func:get-contrib-commands-by-page">
    <xsl:param name="pages" as="xs:string*"/>
    <xsl:param name="content" as="element()+"/>
    
    <xsl:for-each select="$content/descendant-or-self::r:PageBreakCommand[r:PageNumber=$pages]">
      <xsl:sequence select="func:consecutive-contrib-commands(preceding-sibling::r:ContribCommand[1])"/>
    </xsl:for-each>
  </xsl:function>
  
  <xd:doc>
    <xd:short>Find the r:ContribCommand elements that apply to a
    given file (only use if no page divisions exist!).</xd:short>
  </xd:doc>
  <xsl:function name="func:get-contrib-commands-by-file">
    <xsl:param name="file" as="element(r:FileCommand)*"/>
    <xsl:param name="content" as="element()+"/>
    
    <xsl:for-each select="$file">
      <xsl:sequence select="func:consecutive-contrib-commands(preceding-sibling::r:ContribCommand[1])"/>
    </xsl:for-each>
  </xsl:function>
  
  <xd:doc>
    <xd:short>Return the remainder</xd:short>
  </xd:doc>
  <xsl:template match="r:remainder">
    <result-document href="{$output-directory}/REMAINDER.xml">
      <xsl:sequence select="."/>
    </result-document>
  </xsl:template>

  <xd:doc>
    <xd:short>Simple macro to output a two-way conditional, default yes</xd:short>
  </xd:doc>
  <xsl:template name="two-way-condition-yes">
    <tei:vRange>
      <tei:vAlt>
        <tei:symbol value="YES"/>
        <tei:symbol value="NO"/>
      </tei:vAlt>
    </tei:vRange>
    <tei:vDefault>
      <tei:symbol value="YES"/>
    </tei:vDefault>
  </xsl:template>

  <xd:doc>
    <xd:short>Simple macro to output a two-way conditional, default no</xd:short>
  </xd:doc>
  <xsl:template name="two-way-condition-no">
    <tei:vRange>
      <tei:vAlt>
        <tei:symbol value="YES"/>
        <tei:symbol value="NO"/>
      </tei:vAlt>
    </tei:vRange>
    <tei:vDefault>
      <tei:symbol value="NO"/>
    </tei:vDefault>
  </xsl:template>

  <xd:doc>
    <xd:short>Make the targeted pointers for the index file</xd:short>
  </xd:doc>
  <xsl:template match="r:FileCommand" mode="index-selection">
    <tei:ptr target="{concat(func:name-file(.),'.xml')}#main">
      <xsl:attribute name="xml:id" select="concat('se_',string(count(preceding::r:FileCommand) + 1))"/>
    </tei:ptr>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Determine if the segment in $context is broken segment and should
    be combined with the next one</xd:short>
    <xd:detail>A broken segment is a continued segment that does not itself have 
    a pausal and is not in poetry mode.  These should capture most of them!</xd:detail>
  </xd:doc>
  <xsl:function name="func:is-broken-segment" as="xs:boolean">
    <xsl:param name="context" as="element()?"/>
    
    <xsl:sequence select="boolean(
    if ($context)
    then key('broken-segments', $context, $context)
    else false())"/>
    
  </xsl:function>
  
  <xd:doc>
    <xd:short>Count the number of segments preceding this one</xd:short>
    <xd:param name="verse-div">Beginning of verse division, if it exists</xd:param>
  </xd:doc>
  <xsl:function name="func:count-preceding-segments" as="xs:integer">
    <xsl:param name="context" as="element()"/>
    <xsl:param name="verse-div" as="element()?"/>

    <xsl:sequence select="(key('count-of-preceding-segments', generate-id($context), $preceding-segment-count), 0)[1]"/>
    <!-- 
    <xsl:variable name="context-block" as="xs:integer" select="
      if ($verse-div) then 0 
      else func:count-preceding-blocks($context)"/>
    <xsl:variable name="count-start" as="element()"
      select="$context/(preceding::r:FileCommand[1], preceding::*[last()], .)[1]"/>     
    <xsl:sequence select="(if ($verse-div) 
          then count($context/preceding::*
            [(self::r:SegmentedText|self::r:IncludeCommand|self::r:BibleCommand)
            [. >> $verse-div]
            [not(key('broken-segments', .))]])
          else count($context/preceding::*
            [self::r:SegmentedText or self::r:IncludeCommand or self::r:BibleCommand]
            [. >> $count-start]
            [not(key('broken-segments', .))]
            [func:count-preceding-blocks(.)=$context-block]
            ))"/>
       --> 
  </xsl:function>
  
  <xd:doc>
    <xd:short>Return the attributes for a segment, defining its page, paragraph, 
    chapter, verse, etc.</xd:short>
  </xd:doc>
  <xsl:template name="segment-attributes" as="attribute()+">
    <xsl:variable name="starting-point" as="element()" 
        select="(preceding::r:FileCommand[1],preceding::*[last()],.)[1]"/>

    <xsl:attribute name="page" select="preceding::r:PageBreakCommand[1]/r:PageNumber"/>
    <!-- This will cause a problem if versed and unversed text is mixed -->
    <xsl:variable name="verse-div" as="element(r:VerseDivision)?" 
      select="preceding::r:VerseDivision[1]"/>
    <xsl:variable name="chapter" as="xs:string?" select="$verse-div/r:Chapter" />
    <xsl:variable name="verse" as="xs:string?" select="$verse-div/r:Verse"/>
    <!-- xsl:message>segment-attributes for <xsl:value-of select="$chapter"/>:<xsl:value-of select="$verse"/></xsl:message-->
    <xsl:variable name="p-count" as="xs:integer" select="1 +  func:count-preceding-blocks(.)"/>
    <xsl:variable name="first-segment-in-paragraph" as="element()"
      select="preceding-sibling::*
        [self::r:SegmentedText or self::r:BibleCommand or self::r:IncludeCommand]
        [last()]"/>
    <xsl:if test="$verse-div">
      <xsl:attribute name="chapter" select="$chapter"/>
      <xsl:attribute name="verse" select="$verse"/>
    </xsl:if>
    <xsl:attribute name="p" select="$p-count"/>
    <!-- @n counts the number of segments in the verse or paragraph -->
    <xsl:attribute name="n" select="1 + 
      func:count-preceding-segments(., $verse-div)
      "/>
    <!-- @section: section headers may contain other items, so, we keep them
     as idrefs -->
    <xsl:variable name="my-section" as="element(r:SectionCommand)?"
      select="preceding::r:SectionCommand[1][. >> $starting-point]"/>
    <xsl:if test="$my-section">
      <xsl:attribute name="section" select="generate-id($my-section)"/>
    </xsl:if>
    <!-- add line and line group if we're in poetry mode -->
    <xsl:if test="(preceding::r:PoetryMode|preceding::r:ProseMode)[1]/self::r:PoetryMode">
      <xsl:attribute name="lg" select="
        if ($verse) 
        then count(preceding::r:VerseDivision[. >>  $starting-point])
        else $p-count"/>
      <xsl:attribute name="l" select="1 + count(preceding::r:SegmentedText[
        r:EOL and 
        (if ($verse) 
        then (. >> $verse-div) 
        else (. >> preceding-sibling::r:SegmentedText[last()])) ])"/>
    </xsl:if>
    <!-- add the naming group if the text is named  -->
    <xsl:if test="ancestor::r:NamedCommand">
      <xsl:attribute name="name" select="ancestor::r:NamedCommand/r:Id"/>
    </xsl:if>
    <xsl:call-template name="add-rend"/>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Add a continue command, if necessary.</xd:short>
  </xd:doc>
  <xsl:template name="add-cont" as="element(r:ContCommand)?">
      <!-- xsl:message>cont decision for <xsl:value-of select="func:abbr-string(string(.))"/>:
      descendant: <xsl:sequence select="boolean(not(descendant::r:ContCommand))"/>
      preceding sib with verse div: <xsl:sequence select="boolean(not(preceding-sibling::*[self::r:VerseDivision or self::r:SegmentedText or self::r:IncludeCommand or self::r:BibleCommand]))"/>
      previous segment: <xsl:sequence select="boolean(parent::r:ParagraphText/preceding-sibling::r:ParagraphText[1]
          [not(descendant::r:SegmentedText[last()]/r:Pausal = ('.','?','×ƒ'))])"/> 
      match to lowercase: <xsl:sequence select="matches(.,'^\s*\p{Ll}')"/>
      -
      </xsl:message-->
    <!-- xsl:if test="func:has-added-cont-command(.)"-->
    <xsl:if test="key('added-cont-commands', .)">
      <!-- xsl:message>ADDING continue.</xsl:message-->
      <r:ContCommand/>
    </xsl:if>

  </xsl:template>
  
  <xd:doc>
    <xd:short>Add rendering commands to a segment if necessary.
    Should be called from segment-attributes</xd:short>
  </xd:doc>
  <xsl:template name="add-rend" as="attribute()?">
    <xsl:variable name="rend-attribute" as="attribute()">
      <xsl:attribute name="rend" select="
        string-join((
        if (ancestor::r:EmphasisCommand) then 'font-weight:bold;' else (),
        if (ancestor::r:SmallFontCommand) then 'font-size:small;' else (),
        if (ancestor::r:BigFontCommand) then 'font-size:large;' else (),
        if (ancestor::r:ItalicsCommand) then 'font-style:italic;' else (),
        if (ancestor::r:SmallCapsFontCommand) then 'font-variant:small-caps;' else ()
        ), ' ')
      "/>
    </xsl:variable>
    <xsl:if test="normalize-space($rend-attribute)">
      <xsl:sequence select="$rend-attribute"/>
    </xsl:if>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Returns whether the context has an added {cont} command</xd:short>
  </xd:doc>
  <xsl:function name="func:has-added-cont-command" as="xs:boolean">
    <xsl:param name="context" as="element()"/>
    
    <xsl:sequence select="boolean(key('added-cont-commands', $context, $context))"/>
  </xsl:function>
  
  <xd:doc>
    <xd:short>make a segment that records its grouping information.  
    If the segment is the last in the paragraph, and the next paragraph begins
    with a lowercase letter *and* this segment does not already have a continuation
    marker, insert one automatically. </xd:short>
  </xd:doc>
  <xsl:template match="r:SegmentedText|r:IncludeCommand" 
    mode="group-segments">
    
    <xsl:if test="normalize-space(.) and 
      (if (self::r:SegmentedText) 
      then not(key('broken-segments', preceding::r:SegmentedText[1]))
      else true())">
      <xsl:copy>
        <xsl:call-template name="segment-attributes"/>
        <xsl:sequence select="(child::node(),
          if (key('broken-segments', .))
          then following::r:SegmentedText[1]/child::node()
          else ()
        )"/>
        <xsl:call-template name="add-cont"/>
      </xsl:copy>
    </xsl:if>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Convert bible references that may result in more than one
    pointer to multiple bible references</xd:short>
  </xd:doc>
  <xsl:template match="r:BibleCommand|r:BibleBlockCommand" mode="group-segments">
    <xsl:variable name="bible-refs" as="element(tei:ptr)+" 
      select="func:cRef-to-ptr('Biblical', normalize-space(r:bref))"/>

    <xsl:variable name="seg-attributes" as="attribute()*">
      <xsl:choose>
        <xsl:when test="self::r:BibleCommand">
          <xsl:call-template name="segment-attributes"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:attribute name="block" select="1 + func:count-preceding-blocks(.)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="context" select="."/>
    
    <xsl:for-each select="$bible-refs">
      <xsl:element name="{name($context)}">
        <xsl:sequence select="$seg-attributes"/>
        <r:cref><xsl:value-of select="@target"/></r:cref>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>        
   
  <xd:doc>
    <xd:short>Count the number of block commands that precede the block in the current context</xd:short>
  </xd:doc>
  <xsl:function name="func:count-preceding-blocks" as="xs:integer">
    <xsl:param name="context" as="element()"/>
    <xsl:sequence select="(if ($preceding-block-count) then key('count-of-preceding-blocks', generate-id($context), $preceding-block-count) else (), 0)[1]"/>
    
    <!-- 
    <xsl:variable name="origin-element" as="element()"
      select="($context/ancestor::r:ParagraphText[1], $context)[1]"/>
    
    <xsl:variable name="start-point" as="element()" 
      select="$context/(preceding::r:FileCommand[1], root(.)/*[1], .)[1]"/>
    
    <xsl:sequence select="
      count($origin-element/preceding::*
        [. >> $start-point][
        self::r:ParagraphText[normalize-space(.)] or
        self::r:BibleBlockCommand or 
        self::r:IncludeBlockCommand]
        ) 
      (: actual continue commands :)
       - count($origin-element/descendant::r:ContCommand)
      - count($origin-element/preceding::r:ContCommand[. >> $start-point])  
      (: added continue commands :)
      - count(key('added-cont-commands', $origin-element/descendant::r:SegmentedText[1], $origin-element)) 
      - count($origin-element/preceding::*[. >> $start-point]
          [self::r:SegmentedText or self::r:IncludeCommand]
          [key('added-cont-commands', ., $origin-element)])"/>
           -->
    <!-- xsl:message>
    preceding blocks before continue = <xsl:value-of select="count($origin-element/preceding-sibling::*[self::r:ParagraphText or
        self::r:BibleBlockCommand or 
        self::r:IncludeBlockCommand]
        [. >> $start-point])"/>
    descendant continue = <xsl:value-of select="count($origin-element/descendant::r:ContCommand)"/>
    preceding continue = <xsl:value-of select="count($origin-element/preceding::r:ContCommand[. >> $start-point])"/> 
    preceding added = <xsl:value-of select="count($origin-element/descendant::r:SegmentedText[1][func:has-added-cont-command(.)])"/> 
    preceding added = <xsl:value-of select="count($origin-element/preceding::*[self::r:SegmentedText or self::r:IncludeCommand]
            [. >> $start-point][func:has-added-cont-command(.)])"/>
    -
    </xsl:message-->
  </xsl:function>

  <xd:doc>
    <xd:short>Inclusion from elsewhere as a block, @block is an alternative to @p</xd:short>
  </xd:doc>
  <xsl:template match="r:IncludeBlockCommand" mode="group-segments">
    <xsl:copy>
      <xsl:attribute name="block" select="1 + func:count-preceding-blocks(.)"/>
      <xsl:sequence select="child::node()"/>
    </xsl:copy>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Default for group-segments mode is to remove the element</xd:short>
  </xd:doc>
  <xsl:template match="*|text()" mode="group-segments">
  </xsl:template>
  
  <xd:doc>
    <xd:short>Commands that contain segments</xd:short>
  </xd:doc>
  <xsl:template match="r:ParagraphText|
    r:SmallFontCommand|r:IndentCommand|r:BigFontCommand|r:SmallCapsFontCommand|
    r:EmphasisCommand|r:NamedCommand" 
    mode="group-segments">
    <xsl:apply-templates mode="#current"/>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Find the identifier of a segment</xd:short>
    <xd:param name="context">The context to find the identifier of</xd:param>
    <xd:param name="prefix">A prefix to add before the id</xd:param>
    <xd:param name="current-grouping">current grouping, only needed if the segment
    does not have @n</xd:param>
  </xd:doc>
  <xsl:function name="func:segment-id" as="xs:string">
    <xsl:param name="context" as="element()" />
    <xsl:param name="prefix" as="xs:string"/>
    <xsl:param name="current-grouping" as="element()*"/>
    
    <xsl:for-each select="$context">
      <xsl:sequence select="string-join((
        $prefix, '_',
        if (@chapter or @verse) 
        then (
          if (@chapter) then ('c', @chapter, '_') else (),
          if (@verse) then ('v', @verse, '_') else ()
        )
        else if(@p) 
        then ('p', @p, '_')
        else if (@block)
        then ('blk', @block, '_')
        else (), 
        'seg',
        (@n, string(count($current-grouping//* intersect preceding::*[name()=current/name()]) + 1))[1]
        ),'')"/>
    </xsl:for-each>
  </xsl:function>
  
  <xd:doc>
    <xd:short>Make an identifier for a word-level element using its context.</xd:short>
  </xd:doc>
  <xsl:function name="func:word-id" as="xs:string">
    <xsl:param name="context" as="element()"/>
    <xsl:param name="parent-id" as="xs:string"/>
    
    <xsl:sequence select="string-join(($parent-id, '_', 
      $context/local-name(), 
      string(count($context/preceding-sibling::*[
        self::tei:w or self::tei:pc])+1)),'')"/>
  </xsl:function>
  
  <xsl:template match="tei:w|tei:pc" mode="assign-word-id">
    <xsl:param name="parent-id" as="xs:string"/>
    <xsl:copy>
      <xsl:attribute name="xml:id" 
        select="func:word-id(., $parent-id)"/>
      <xsl:sequence select="@*|node()"/>
    </xsl:copy>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Drop added XML from split-word</xd:short>
  </xd:doc>
  <xsl:template match="ends|endp" mode="assign-word-id"/>
  
  <xd:doc>Identity template</xd:doc>
  <xsl:template match="*" mode="assign-word-id">
    <xsl:param name="parent-id" as="xs:string"/>
    
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="#current">
        <xsl:with-param name="parent-id" as="xs:string" 
          select="(@xml:id, $parent-id)[1]"/>
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>
  
  <xd:doc>
    Remove footnote references and include commands from a repository
  </xd:doc>
  <xsl:template match="*" mode="remove-footrefs">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="tei:ptr|r:FootRefCommand|r:SectionCommand" mode="remove-footrefs" />
  
  <xsl:template match="r:InSegmentCommand|r:InParagraphCommand|r:HebrewCommand|r:SectionCommand" 
    mode="repository">
    <xsl:apply-templates select="element()" mode="#current"/>
  </xsl:template>
  
  <xsl:template match="r:SegmentedText" mode="repository">
    <xsl:param name="current-grouping" as="element()+" tunnel="yes" required="yes"/>
    
    <xsl:variable name="my-id" as="xs:string" 
      select="func:segment-id(., 'r', $current-grouping)"/>
    
    <tei:seg>
      <xsl:attribute name="xml:id" select="$my-id"/>
      <!-- copy rendering instructions -->
      <xsl:sequence select="@rend"/>
      
      <xsl:variable name="words">
        <xsl:apply-templates mode="#current"/>
      </xsl:variable>
      <xsl:apply-templates select="$words" mode="assign-word-id">
        <xsl:with-param name="parent-id" as="xs:string" select="$my-id"/>
      </xsl:apply-templates>
    </tei:seg>
  </xsl:template>
  
  
  <xd:doc>
    <xd:short>Segment that contains only a HebrewCommand</xd:short>
    <!-- TODO: why do we need this? -->
  </xd:doc>
  <xsl:template match="r:SegmentedText[
    r:InSegmentCommand/r:HebrewCommand and 
    not(element()[not(self::r:InSegmentCommand|self::r:EOL)])]" mode="repository">
    <xsl:apply-templates mode="#current"/>
  </xsl:template>
  
  <xsl:template match="r:XMLLikeCommand" mode="repository">
    <xsl:apply-templates select="r:ItalicsCommand" mode="#current"/>
  </xsl:template>
  
  <xsl:template match="r:ItalicsCommand" mode="repository">
    <tei:hi rend="italic">
      <xsl:apply-templates select="r:ItalicsText" mode="#current"/>
    </tei:hi>
  </xsl:template>
  
  <xsl:template match="r:SmallFontCommand" mode="repository">
    <tei:hi rend="small">
      <xsl:apply-templates select="r:SmallFontText" mode="#current"/>
    </tei:hi>
  </xsl:template>
  
  <xsl:template match="r:SicCommand" mode="repository">
    <tei:choice>
      <tei:sic><xsl:apply-templates select="r:IncorrectText" mode="#current"/></tei:sic>
      <tei:corr><xsl:apply-templates select="r:CorrectText" mode="#current"/></tei:corr>
    </tei:choice>
  </xsl:template>
  
  <xd:doc>
    <xd:short>TranslitCommand with both original language and as written generates a choice construct</xd:short>
  </xd:doc>
  <xsl:template match="r:TranslitCommand[r:OriginalLanguage]" mode="repository">
    <xsl:variable name="base-id" as="xs:string" select="concat('translit-',generate-id(.))"/>
    <tei:choice>
      <xsl:attribute name="xml:id" select="concat($base-id,'-choice')"/>
      <j:option>
        <xsl:attribute name="xml:id" select="concat($base-id,'-aswritten')"/>
        <tei:foreign xml:lang="{r:LangCode}"><xsl:apply-templates select="r:AsWritten" mode="#current"/></tei:foreign>
      </j:option>
      <j:option>
        <xsl:attribute name="xml:id" select="concat($base-id,'-custom')"/>
        <j:segGen type="transliteration" xml:lang="{substring-before(r:LangCode, '-')}"><xsl:apply-templates select="r:OriginalLanguage" mode="#current"/></j:segGen>
      </j:option>
    </tei:choice>
  </xsl:template>
  
  <xd:doc>
    <xd:short>TranslitCommand with both original language and as written generates a choice construct</xd:short>
  </xd:doc>
  <xsl:template match="r:TranslitCommand[r:OriginalLanguage]" mode="make-conditional-references">
    <xsl:variable name="base-id" as="xs:string" select="concat('translit-',generate-id(.))"/>
    <!-- note: if this is a translation, conditionals are at ../../ -->
    <tei:link type="association" targets="#{$base-id}-aswritten /group/core/conditionals/TransliterationChoice.xml#as-written-Y">
      <xsl:attribute name="xml:id" select="concat($base-id, '-as-written-Y-link')"/>
    </tei:link>
    <tei:link type="association" targets="#{$base-id}-custom /group/core/conditionals/TransliterationChoice.xml#as-custom-Y">
      <xsl:attribute name="xml:id" select="concat($base-id, '-as-custom-Y-link')"/>
    </tei:link>
  </xsl:template>
 
  <xsl:template match="text()" mode="make-conditional-references"/> 

  <xsl:template match="r:TranslitCommand[not(r:OriginalLanguage)]" mode="repository">
    <tei:foreign xml:lang="{r:LangCode}"><xsl:apply-templates select="r:AsWritten" mode="#current"/></tei:foreign>
  </xsl:template>
 
  <xsl:template match="r:DivineNameCommand" mode="repository">
    <j:divineName><xsl:apply-templates select="r:DivineName" mode="#current"/></j:divineName>
  </xsl:template>
 
  <xsl:template match="r:HebrewText" mode="repository">
    <xsl:param name="current-grouping" as="element()+" tunnel="yes" required="yes"/>
    <tei:seg 
      xml:lang="he">
      <xsl:attribute name="xml:id" select="func:segment-id(ancestor::r:SegmentedText[1], 'r', $current-grouping)"/>
      <xsl:apply-templates mode="#current"/>
    </tei:seg>
  </xsl:template>

  <xsl:template match="r:Pausal" mode="repository">
    <tei:pc>
      <xsl:apply-templates mode="#current"/>
    </tei:pc>
    <xsl:text> </xsl:text>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Replace en-dash</xd:short>
  </xd:doc>
  <xsl:template match="r:Pausal/text()" mode="repository">
    <xsl:sequence select="replace(.,'--','&#x2015;')"/>
  </xsl:template>

  <xsl:template match="r:Escape" mode="repository">
    <xsl:value-of select="substring-after(., '\')"/>
  </xsl:template>
  
  <xsl:template match="r:TextualContent" mode="repository">
    <xsl:apply-templates mode="#current"/>
  </xsl:template>
  
  <xd:doc>
    Leave behind a footnote reference so it can be found later
  </xd:doc>
  <xsl:template match="r:FootRefCommand[following::*[1]/self::r:TextualContent]" mode="repository">
  
    <!-- xsl:message>footrefcommand from=<xsl:sequence select="string-join(('note',
      string(ancestor::r:SegmentedText/@page),
      r:Reference),'_')"/>
    
    ancestor = <xsl:sequence select="ancestor::r:SegmentedText"/>
    page = <xsl:sequence select="ancestor::r:SegmentedText/@page"/>
    </xsl:message-->
    <r:FootRefCommand from="{string-join(('note',
      string(ancestor::r:SegmentedText/@page),
      r:Reference),'_')}"/>
    
  </xsl:template>
  
  <xsl:template match="r:IncludeCommand|r:IncludeBlockCommand" mode="repository">
    <xsl:param name="current-grouping" as="element()+" tunnel="yes" required="yes"/>
    
    <xsl:variable name="my-id" as="xs:string" 
      select="func:segment-id(., 'se', $current-grouping)"/>
    <xsl:variable name="uri" as="xs:string"
      select="normalize-space(r:URI)"/> 
    <tei:ptr target="{if (contains($uri, '#')) then $uri else concat($uri, '#main')}">
      <xsl:attribute name="xml:id" select="$my-id"/>
    </tei:ptr>
  </xsl:template>
  
  <xsl:template match="r:BibleCommand|r:BibleBlockCommand" mode="repository">
    <xsl:param name="current-grouping" as="element()+" tunnel="yes" required="yes"/>
    
    <xsl:variable name="my-id" as="xs:string" 
      select="func:segment-id(., 'se', $current-grouping)"/>
    
    <tei:ptr target="{normalize-space(r:cref)}">
      <xsl:attribute name="xml:id" select="$my-id"/>
    </tei:ptr>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Commands that do nothing in repository mode</xd:short>
  </xd:doc>
  <xsl:template match="r:EOL|r:ContCommand|r:FootRefCommand|
  r:FootnotePageBreakCommand|r:NoteCommand" 
    mode="repository"/>
  
  <xd:doc>
    <xd:short>Convert text to word and punctuation.  
    If it's Hebrew text, correct common typing errors.</xd:short>
  </xd:doc>
  <xsl:template match="text()" mode="repository" as="element()*">
    <!-- correct nonbreaking spaces to space -->
    <xsl:variable name="text-space" select="translate(., '&#160;', ' ')"/>
    <xsl:if test="normalize-space($text-space)">
      <!-- xsl:message>Passing to split-words: "<xsl:value-of select="string-to-codepoints(.)"/>"</xsl:message-->
      <xsl:variable name="split" as="element()+">
        <xsl:call-template name="split-words-no-ignore">
          <xsl:with-param name="original-string" select="$text-space" as="xs:string"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="matches(., '\p{IsHebrew}', 's')">
          <!-- contains any Hebrew, need to pre-encode it to correct common
          Hebrew typing issues
           -->
          <xsl:apply-templates select="$split[self::tei:w or self::tei:pc]" mode="pre-encode"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$split[self::tei:w or self::tei:pc]"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template> 
  
  <xd:doc>
    <xd:short>Make a selection out of all the elements in a repository</xd:short>
  </xd:doc>
  <xsl:template match="tei:seg" mode="selection">
    <tei:ptr target="#{@xml:id}">
      <xsl:attribute name="xml:id" select="replace(@xml:id, 'r_', 'se_')"/>
    </tei:ptr>
  </xsl:template>
  
  <xsl:template match="text()" mode="selection"/>
  
  <xd:doc>
    <xd:short>ptr in a repository is for including, just copy it to the selection</xd:short>
  </xd:doc>
  <xsl:template match="tei:ptr" mode="selection">
    <xsl:sequence select="."/>
  </xsl:template>
  
  <xsl:template match="r:SegmentedText|r:IncludeCommand|r:BibleCommand" mode="p">
    <xsl:param name="current-grouping" as="element()+"/>
    
    <xsl:variable name="my-id" as="xs:string" 
      select="func:segment-id(., '', $current-grouping)"/>
    <!-- _pX_segYYY is the xml:id coming out of $my-id.  Remove the leading _ -->
    <tei:ptr target="#se{$my-id}">
      <xsl:attribute name="xml:id" 
        select="if (starts-with($my-id,'_p')) 
        then substring($my-id,2)
        else string-join(('p', @p, $my-id),'')"/>
    </tei:ptr>
  </xsl:template>

  <xsl:template match="r:IncludeBlockCommand|r:BibleBlockCommand|text()" mode="p l verse"/>
  
  <xsl:template match="r:IncludeCommand|r:BibleCommand|text()" mode="verse"/>
  
  <xsl:template match="r:SegmentedText" mode="l">
    <xsl:param name="current-grouping" as="element()+"/>
    
    <xsl:variable name="my-id" as="xs:string" 
      select="func:segment-id(., '', $current-grouping)"/>
    <tei:ptr
      target="#se{$my-id}">
      <xsl:attribute name="xml:id" select="concat('lg',@lg,'_l',@l,'_seg',@n)"/>
    </tei:ptr>
  </xsl:template>

  <xsl:template match="r:SegmentedText" mode="name">
    <xsl:param name="current-grouping" as="element()+"/>
    
    <xsl:variable name="my-id" as="xs:string" 
      select="func:segment-id(., '', $current-grouping)"/>
    <tei:ptr
      target="#se{$my-id}">
      <xsl:attribute name="xml:id" select="concat('named_',@name,'_seg',@n)"/>
    </tei:ptr>
  </xsl:template>

  
  <xsl:template match="r:SegmentedText" mode="verse">
    <xsl:param name="current-grouping" as="element()+"/>
    
    <xsl:variable name="my-id" as="xs:string" 
      select="func:segment-id(., '', $current-grouping)"/>
    <tei:ptr target="#se{$my-id}">
      <xsl:attribute name="xml:id" select="concat('ab',$my-id)"/>
    </tei:ptr>
  </xsl:template>

  <xd:doc>
    <xd:short>Page reference - provide a tei:ref to the page.</xd:short>
    <xd:param name="current-grouping">The context of the command, relative to 
    the document tree that's being processed.  If empty, the document tree
    must be the original document tree.</xd:param>
  </xd:doc>
  <xsl:template match="r:PageReferenceCommand" mode="repository">
    <xsl:param name="current-grouping" as="element()*" tunnel="yes" />
    <xsl:variable name="current-file" as="xs:string"
      select="func:name-file(preceding::r:FileCommand[1])"/>
    <xsl:variable name="page-break" as="element(r:PageBreakCommand)"
      select="root(($current-grouping[1], .)[1])//r:PageBreakCommand[r:PageNumber=current()/r:PageNumber]"/>
    <xsl:variable name="page-file-element" as="element(r:FileCommand)?"
      select="$page-break/preceding::r:FileCommand[1]"/>
    <xsl:variable name="page-file" as="xs:string"
      select="concat(func:name-file($page-file-element),'.xml')"/>
    <tei:ref target="{string-join((
      if ($current-file != $page-file)
      then $page-file 
      else '',
      '#',
      func:segment-id($page-break/following::r:SegmentedText[1],'', 
        $page-file-element/following-sibling::*
        [. &lt;&lt; $page-file-element/following-sibling::r:FileCommand[1]]) 
      ),'')
      }">
      <xsl:value-of select="string-join((
        if (starts-with(r:ReferenceType,'prr'))
        then ()
        else 'p. ',
        r:PageNumber
      ), ' ')"/>
    </tei:ref>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Turn a reference into a tei:ref</xd:short>
  </xd:doc>
  <xsl:template match="r:ReferenceCommand" mode="repository">
    <tei:ref target="{r:Reference}">
      <xsl:value-of select="r:Text"/>
    </tei:ref>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Make an xml:id for a note</xd:short>
  </xd:doc>
  <xsl:function name="func:make-note-id" as="xs:string">
    <xsl:param name="note-command" as="element()"/>
    
    <xsl:sequence select="string-join(('note',
      $note-command/preceding::r:PageBreakCommand[1]/r:PageNumber,
      translate(($note-command/r:Number, $note-command/r:Reference,
        string(1 + key('count-of-preceding-notes', 
          generate-id($note-command), 
          $preceding-note-count)))[1],'*â€ â€¡','SCD')),'_')"/>
  </xsl:function>
  
  <xd:doc>
    <xd:short>Turn a foot note command into a referencable note
    (the content is essentially like a repository)</xd:short>
  </xd:doc>
  <xsl:template match="r:FootNoteCommand" mode="make-notes">
    <tei:note>
      <xsl:attribute name="xml:id" select="func:make-note-id(.)"/>
      <xsl:apply-templates select="* except r:Number" mode="repository"/>
    </tei:note>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Turn an explanatory note command into a referencable note
    (the content is essentially like a repository)</xd:short>
  </xd:doc>
  <xsl:template match="r:NoteCommand" mode="make-notes">
    <tei:note>
      <xsl:attribute name="xml:id" select="func:make-note-id(.)"/>
      <xsl:apply-templates select="element()" mode="repository"/>
    </tei:note>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Set up foot note links</xd:short>
  </xd:doc>
  <xsl:template match="r:FootNoteCommand" mode="make-note-references">
    <xsl:param name="base-file-name" as="xs:string"/>
    <xsl:param name="repository" as="element()+"/>
  
    <xsl:variable name="my-reference" as="element(r:FootRefCommand)" 
      select="preceding::r:FootRefCommand[r:Reference eq current()/r:Number][1]"/>
    <xsl:variable name="ref-to" as="element()" 
        select="$my-reference/following::r:*[1]"/>
    <xsl:variable name="target-to" as="xs:string"
      select="concat(' #', func:make-note-id(.))"/>    
    
    <!-- xsl:message>footnote: <xsl:sequence select="."/> 
    
    my-reference: <xsl:sequence select="$my-reference"/>
    ref-to: <xsl:sequence select="$ref-to"/>
    </xsl:message-->
    <xsl:choose>
      <xsl:when test="$ref-to/self::r:VerseDivision">
        <tei:link type="note" targets="{string-join((
          $base-file-name, '.xml#c', $ref-to/r:Chapter, '_v', $ref-to/r:Verse, 
          $target-to),'')}"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:for-each select="$repository//r:FootRefCommand
          [@from eq func:make-note-id(current())]/following-sibling::*[1]/@xml:id">
          <tei:link type="note" targets="{string-join((
            $base-file-name, '.xml#', string(.), $target-to), '')}"/>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:template>
 
 
   <xd:doc>
    <xd:short>Set up non-footnote note links</xd:short>
  </xd:doc>
  <xsl:template match="r:NoteCommand" mode="make-note-references">
    <xsl:param name="base-file-name" as="xs:string"/>
    <xsl:param name="repository" as="element()+"/>
  
    <xsl:variable name="ref-to" as="element()" 
        select="following::r:*[self::r:VerseDivision or
          self::r:ParagraphText or
          self::r:SectionCommand or 
          self::r:SegmentedText][1]"/>
    <xsl:variable name="target-to" as="xs:string"
      select="concat(' #', func:make-note-id(.))"/>    
    
    <tei:link type="note">
      <xsl:choose>
        <xsl:when test="$ref-to/self::r:VerseDivision">
          <xsl:attribute name="targets" select="string-join((
            $base-file-name, '.xml#c', $ref-to/r:Chapter, '_v', $ref-to/r:Verse, 
            $target-to),'')"/>
        </xsl:when>
        <xsl:when test="$ref-to/self::r:SectionCommand">
          <xsl:variable name="start-point" as="element()" 
            select="(preceding::r:FileCommand[1], root(.)//*[1], .)[1]"/>
          <xsl:attribute name="targets" select="string-join((
            $base-file-name, '.xml#section', 
              string(count(preceding::r:SectionCommand[. >> $start-point]) + 1), 
            $target-to),'')"/>
        </xsl:when>
        <xsl:when test="$ref-to/self::r:ParagraphText">
          <xsl:attribute name="targets" select="string-join((
            $base-file-name, '.xml#p', 
              string(1 + func:count-preceding-blocks($ref-to)), 
            $target-to),'')"/>
        </xsl:when>
        <xsl:otherwise>
          <!-- segmentedtext as a fallback.  If you get here, it's probably
          targetted wrong -->
          <xsl:attribute name="targets" select="string-join((
            $base-file-name, '.xml#', func:segment-id($ref-to, 'se', ()), 
            $target-to), '')"/>
          <xsl:sequence select="func:debug('A note is attached to a segment.  It will likely be unlinked.', 'r:NoteCommand',$debug-error)"/>
        </xsl:otherwise>
      </xsl:choose>
    </tei:link>   
  </xsl:template>
 
 
  <xd:doc>
  	<xd:short>Entry point for processing as XML (a single text element, no namespace)</xd:short>
    <xd:detail>BROKEN</xd:detail>
  </xd:doc>
  <xsl:template match="text">
  	<xsl:call-template name="main">
  	</xsl:call-template>
  </xsl:template>
  
  <xd:doc>
    <xd:short>Start at main, if you can't call by template (eg, from the database)</xd:short>
  </xd:doc>
  <xsl:template match="main"> 
    <xsl:call-template name="main"/> 
  </xsl:template>
  
  <xd:doc>
    Standalone processing with output to multiple files.
  </xd:doc>
  <xsl:template name="standalone">
    <xsl:variable name="main-result">
      <xsl:call-template name="main"/>
    </xsl:variable>
    <xsl:for-each select="$main-result/result-document">
      <xsl:result-document href="{@href}">
        <xsl:sequence select="child::node()"/>
      </xsl:result-document>
    </xsl:for-each>
  </xsl:template>
  
  <xd:doc>
  	<xd:short>Entry point for standalone processing</xd:short>
  </xd:doc> 
  <xsl:template name="main">
    <xsl:apply-templates select="$grammar-parsed"/>
  </xsl:template>
</xsl:stylesheet>
